# Tips

---

- ./gradlew clean build : 지우고 새로 빌드
- build -> libs -> snapshot : 배포할때 쓰이는 jar 파일
  - 실행 : java -jar japshop-0.0.1-SNAPSHOT.jar
- 쿼리 파라미터 로그 남기기
  - org.hibernate.type: trace
- **엔티티 설계**
  - 엔티티 설계 단계에서는 양방향 관계보다 단방향 관계를 써라(필요없는 경우가 많음, 단순 Filter로 취득 가능하기 때문에 )
  - ManyToMany 는 쓰면 안된다 * - *, Mapping 데이터 둬서, 일대다 다대일로 풀어야 된다
  - db에는 소문자 + 언더스코어 사용
  - 연관관계 주인 : 일대다에서 다에 외래키 존재하는쪽이 다(연관관계 주인)
    - 주인쪽에 값을 변경해야 값이 변경됨
    - 반대편은 mappedBy 단순한 거울이다(조회용)
  - 단방향 표시(->)
  - 일대일 관계는 외래키 어디다 놔도 상관 없다
  - 상황에 따라서, 정합성의 중요도에따라서 외래키 걸어주는게 좋을때가 있다, 아니면 인덱스만 잘잡아줘도 된다
- Getter는 기본적으로 열어주는 것이 편하다, Setter의 경우 데이터의 변형 가능성이 있다 -> 어떻게 엔티티가 수정이 되는지 파악이 되지 않는 문제가 있다, 변경이 필요할떄 어디서 변경되는지 다 찾아야된다, 변경지점이 명확하게 , 변경용 비즈니스 메서드를 제공하는 게 좋다(유지보수를 위해), Setter를 다 닫는게 좋다(여기는 예제일 뿐)
- table_id -> 단순히id이면 찾기가 쉽지 않다, Join 불편하다(명확하지 않음)
- ⭐엔티티 설계 주의
  - Setter 열지 말기(변경 메소드 만들기)
  - 모든 연관관계는 지연로딩으로 설정!!(외워야함)
    - 즉시로딩 : 필요한 시점에 다른애들 다 로딩해버림(연관관계 있는)
      - 추적하기가 매우 까다롭다
      - JPQL 실행시 N+1 자주 발생
      - @XToOne 디폴트가 즉시로딩이므로 직접 지연로딩으로 설정해야 됨 -> Lazy로 다바꿔야됨
    - fetch join, 엔티티 그래프를 사용한다(최적화)
- 개발 패턴
  - 도메인에 비즈니스 로직 넣어서 Service에는 단순위임 : 도메인 모델 패턴
  - Service에 비즈니스 몰아넣는 스타일 : 트랜잭션 스크립트 패턴
  - 양립하는 경우도 있다
- 화면과 API는 컨트롤러를 분리하는게 좋다(공통요소가 많이 다르기 때문), 공통 에러 대응 등
- ⭐상항 지연로딩을 기본으로 하고, 성능 최적화가 꼭 필요한 경우에는 패치 조인(fetch join)을 사용!!